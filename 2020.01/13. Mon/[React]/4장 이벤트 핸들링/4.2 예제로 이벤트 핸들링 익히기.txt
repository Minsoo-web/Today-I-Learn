이 장은 예제를 통한 학습으로 
제가 몰랐었던 점들이나 기억해둬야 할 것들만 따로 필기하겠습니다. 

1. 컴포넌트 생성 및 불러오기 
2. onChange 이벤트 핸들링하기 
3. 임의 메서드 만들기 
4. input 여러개 다루기 
5. onKeyPress 이벤트 핸들링하기 

1.  컴포넌트 생성 및 불러오기 
2.  
    onChange= {
        (e)=>{
            console.log(e);
        }
    }

    여기서 콘솔에 기록되는 e 객체는 SyntjetocEvent로 웹 브라우저의 네이티브 
    이벤트를 감싸는 객체입니다. 
    네이티브 이벤트와 인터페이스가 같으므로 
    순수 자바스크립트에서 HTML 이벤트를 다룰 때와 똑같이 사용 할 수 있습니다. 

    SyntjetocEvent는 네이티브 이벤트와 달리 이벤트가 끝나고 나면 
    이벤트가 초기화 되므로 정보를 참조할 수 없습니다. 
    예를 들어 0.5초 뒤에 e 객체를 참조하면 e 객체 내부의 모든 값이 비워지게 됩니다. 

    만약 비동기적으로 이벤트 객체를 참조할 일이 있다면 e.persist 함수를 호출해야합니다.
    예를들어 onChange 이벤트가 발생할 때 
    앞으로 변할 인풋 값인 e.target.value 를 콘솔에 기록해 보겠습니다. 

2-1 ) state에 input 값 담기 
      1. value = {this.state.name} 
         인풋의 value를 state화 해줌 
      2. onChange = { 
          (e)=>{
              this.setState({
                  message : e.target.value 
              })
          }
      }
2-3 ) 함수가 호출될 때 this는 호출부에 따라 결정되므로, 클래스의 임의 메서드가 
      특정 HTML 요소의 이벤트로 등록되는 과정에서 메서드와 this의 관계가 끊어지게 됩니다. 
      이 때문에 임의 메소드가 등록되어도 this를 컴포넌트 자신으로 가리키기 위해서는 
      메서드를 this와 바인딩 하는 작업이 필요합니다. 
      만약 바인딩하지 않게되면 this가 undefined를 가리키게 됩니다. 

      때문에 기존의 함수 형태가 아닌 ES 6의 화살표 함수를 사용하여 메서드를 정의하게 되면 
      this의 연결 고리가 유지가 됩니다. 

      